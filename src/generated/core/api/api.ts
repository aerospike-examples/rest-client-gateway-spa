/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BatchRead
 */
export interface BatchRead {
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchRead
     */
    binNames?: Array<string>;
    /**
     * 
     * @type {Key}
     * @memberof BatchRead
     */
    key?: Key;
    /**
     * 
     * @type {boolean}
     * @memberof BatchRead
     */
    readAllBins?: boolean;
    /**
     * 
     * @type {Record}
     * @memberof BatchRead
     */
    record?: Record;
}
/**
 * 
 * @export
 * @interface BatchReadRequest
 */
export interface BatchReadRequest {
    /**
     * List of bins to limit the record response to.
     * @type {Array<string>}
     * @memberof BatchReadRequest
     */
    binNames?: Array<string>;
    /**
     * Key to retrieve a record
     * @type {Key}
     * @memberof BatchReadRequest
     */
    key?: Key;
    /**
     * Whether all bins should be returned with this record
     * @type {boolean}
     * @memberof BatchReadRequest
     */
    readAllBins?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterInformation
 */
export interface ClusterInformation {
    /**
     * 
     * @type {Array<NamespaceInformation>}
     * @memberof ClusterInformation
     */
    namespaces?: Array<NamespaceInformation>;
    /**
     * 
     * @type {Array<NodeInformation>}
     * @memberof ClusterInformation
     */
    nodes?: Array<NodeInformation>;
}
/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * URL safe base64 encoded key digest. Returned by the server on batch responses. May be provided by client.
     * @type {string}
     * @memberof Key
     */
    digest?: string;
    /**
     * Enum describing the type of the userKey. This field is omitted in MessagePack responses.
     * @type {string}
     * @memberof Key
     */
    keytype?: KeyKeytypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    namespace: string;
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    setName?: string;
    /**
     * The user key, it may be a string, integer, or URL safe Base64 encoded bytes.
     * @type {any}
     * @memberof Key
     */
    userKey?: any;
}

/**
 * @export
 * @namespace Key
 */
// export namespace Key {
    /**
     * @export
     * @enum {string}
     */
    export enum KeyKeytypeEnum {
        STRING = 'STRING' as any ,
        INTEGER = 'INTEGER' as any ,
        BYTES = 'BYTES' as any ,
        DIGEST = 'DIGEST' as any 
    }
//}

/**
 * 
 * @export
 * @interface NamespaceInformation
 */
export interface NamespaceInformation {
    /**
     * 
     * @type {string}
     * @memberof NamespaceInformation
     */
    name?: string;
    /**
     * 
     * @type {Array<RestClientSetInformation>}
     * @memberof NamespaceInformation
     */
    sets?: Array<RestClientSetInformation>;
}
/**
 * 
 * @export
 * @interface NodeInformation
 */
export interface NodeInformation {
    /**
     * 
     * @type {string}
     * @memberof NodeInformation
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * 
     * @type {any}
     * @memberof Operation
     */
    opValues: any;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    operation: string;
}
/**
 * 
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * 
     * @type {string}
     * @memberof Privilege
     */
    code: PrivilegeCodeEnum;
    /**
     * Namespace Scope
     * @type {string}
     * @memberof Privilege
     */
    namespace?: string;
    /**
     * setName Scope
     * @type {string}
     * @memberof Privilege
     */
    set?: string;
}

/**
 * @export
 * @namespace Privilege
 */
// export namespace Privilege {
    /**
     * @export
     * @enum {string}
     */
    export enum PrivilegeCodeEnum {
        UserAdmin = 'user-admin' as any ,
        SysAdmin = 'sys-admin' as any ,
        DataAdmin = 'data-admin' as any ,
        Read = 'read' as any ,
        ReadWrite = 'read-write' as any ,
        ReadWriteUdf = 'read-write-udf' as any 
    }
//}

/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * A mapping from binName to binValue
     * @type {any}
     * @memberof Record
     */
    bins?: any;
    /**
     * The generation of the record.
     * @type {number}
     * @memberof Record
     */
    generation?: number;
    /**
     * The time to live for the record, in seconds from now.
     * @type {number}
     * @memberof Record
     */
    ttl?: number;
}
/**
 * Error object returned from unsuccesful operations.
 * @export
 * @interface RestClientError
 */
export interface RestClientError {
    /**
     * A boolean specifying whether it was possible that the operation succeeded. This is only included if true.
     * @type {boolean}
     * @memberof RestClientError
     */
    inDoubt?: boolean;
    /**
     * A message describing the cause of the error.
     * @type {string}
     * @memberof RestClientError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface RestClientIndex
 */
export interface RestClientIndex {
    /**
     * The bin which is indexed
     * @type {string}
     * @memberof RestClientIndex
     */
    bin?: string;
    /**
     * 
     * @type {string}
     * @memberof RestClientIndex
     */
    collectionType?: RestClientIndexCollectionTypeEnum;
    /**
     * The name of the index. This must be unique per set
     * @type {string}
     * @memberof RestClientIndex
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RestClientIndex
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof RestClientIndex
     */
    set?: string;
    /**
     * 
     * @type {string}
     * @memberof RestClientIndex
     */
    type?: RestClientIndexTypeEnum;
}

/**
 * @export
 * @namespace RestClientIndex
 */
// export namespace RestClientIndex {
    /**
     * @export
     * @enum {string}
     */
    export enum RestClientIndexCollectionTypeEnum {
        DEFAULT = 'DEFAULT' as any ,
        LIST = 'LIST' as any ,
        MAPKEYS = 'MAPKEYS' as any ,
        MAPVALUES = 'MAPVALUES' as any 
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestClientIndexTypeEnum {
        NUMERIC = 'NUMERIC' as any ,
        STRING = 'STRING' as any ,
        GEO2DSPHERE = 'GEO2DSPHERE' as any 
    }
//}

/**
 * 
 * @export
 * @interface RestClientRole
 */
export interface RestClientRole {
    /**
     * 
     * @type {string}
     * @memberof RestClientRole
     */
    name?: string;
    /**
     * 
     * @type {Array<Privilege>}
     * @memberof RestClientRole
     */
    privileges?: Array<Privilege>;
}
/**
 * 
 * @export
 * @interface RestClientSetInformation
 */
export interface RestClientSetInformation {
    /**
     * 
     * @type {string}
     * @memberof RestClientSetInformation
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof RestClientSetInformation
     */
    objectCount?: number;
}
/**
 * 
 * @export
 * @interface RestClientUserModel
 */
export interface RestClientUserModel {
    /**
     * 
     * @type {string}
     * @memberof RestClientUserModel
     */
    password?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RestClientUserModel
     */
    roles?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RestClientUserModel
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    roles?: Array<string>;
}

/**
 * ClusterInformationOperationsApi - fetch parameter creator
 * @export
 */
export const ClusterInformationOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return an object containing information about the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterInfo(options: any = {}): FetchArgs {
            const localVarPath = `/v1/cluster`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterInformationOperationsApi - functional programming interface
 * @export
 */
export const ClusterInformationOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return an object containing information about the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClusterInformation> {
            const localVarFetchArgs = ClusterInformationOperationsApiFetchParamCreator(configuration).getClusterInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClusterInformationOperationsApi - factory interface
 * @export
 */
export const ClusterInformationOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Return an object containing information about the Aerospike cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterInfo(options?: any) {
            return ClusterInformationOperationsApiFp(configuration).getClusterInfo(options)(fetch, basePath);
        },
    };
};

/**
 * ClusterInformationOperationsApi - object-oriented interface
 * @export
 * @class ClusterInformationOperationsApi
 * @extends {BaseAPI}
 */
export class ClusterInformationOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Return an object containing information about the Aerospike cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterInformationOperationsApi
     */
    public getClusterInfo(options?: any) {
        return ClusterInformationOperationsApiFp(this.configuration).getClusterInfo(options)(this.fetch, this.basePath);
    }

}

/**
 * KeyValueOperationsApi - fetch parameter creator
 * @export
 */
export const KeyValueOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling createRecordNamespaceKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling createRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling createRecordNamespaceSetKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling createRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling createRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceKey(key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceSetKey(key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling deleteRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceKey(key: string, namespace: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (bins) {
                localVarQueryParameter['bins'] = bins;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceSetKey(key: string, namespace: string, set: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling getRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (bins) {
                localVarQueryParameter['bins'] = bins;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceKey(key: string, namespace: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling recordExistsNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling recordExistsNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceSetKey(key: string, namespace: string, set: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling recordExistsNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling recordExistsNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling recordExistsNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling replaceRecordNamespaceKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling replaceRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling replaceRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling replaceRecordNamespaceSetKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling replaceRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling replaceRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling replaceRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling updateRecordNamespaceKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateRecordNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateRecordNamespaceKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'bins' is not null or undefined
            if (bins === null || bins === undefined) {
                throw new RequiredError('bins','Required parameter bins was null or undefined when calling updateRecordNamespaceSetKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateRecordNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateRecordNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling updateRecordNamespaceSetKey.');
            }
            const localVarPath = `/v1/kvs/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(bins || {}) : (bins || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeyValueOperationsApi - functional programming interface
 * @export
 */
export const KeyValueOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).createRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).createRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceKey(key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).deleteRecordNamespaceKey(key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceSetKey(key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).deleteRecordNamespaceSetKey(key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceKey(key: string, namespace: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).getRecordNamespaceKey(key, namespace, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceSetKey(key: string, namespace: string, set: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).getRecordNamespaceSetKey(key, namespace, set, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceKey(key: string, namespace: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).recordExistsNamespaceKey(key, namespace, keytype, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceSetKey(key: string, namespace: string, set: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).recordExistsNamespaceSetKey(key, namespace, set, keytype, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).replaceRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).replaceRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).updateRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeyValueOperationsApiFetchParamCreator(configuration).updateRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KeyValueOperationsApi - factory interface
 * @export
 */
export const KeyValueOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).createRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new record with the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).createRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceKey(key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).deleteRecordNamespaceKey(key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordNamespaceSetKey(key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).deleteRecordNamespaceSetKey(key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceKey(key: string, namespace: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).getRecordNamespaceKey(key, namespace, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return the metadata and bins for a record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordNamespaceSetKey(key: string, namespace: string, set: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).getRecordNamespaceSetKey(key, namespace, set, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceKey(key: string, namespace: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any) {
            return KeyValueOperationsApiFp(configuration).recordExistsNamespaceKey(key, namespace, keytype, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check if a record exists
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordExistsNamespaceSetKey(key: string, namespace: string, set: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any) {
            return KeyValueOperationsApiFp(configuration).recordExistsNamespaceSetKey(key, namespace, set, keytype, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).replaceRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace the bins of the specified record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).replaceRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).updateRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Merge the provided bins into the record.
         * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return KeyValueOperationsApiFp(configuration).updateRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
    };
};

/**
 * KeyValueOperationsApi - object-oriented interface
 * @export
 * @class KeyValueOperationsApi
 * @extends {BaseAPI}
 */
export class KeyValueOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new record with the provided bins into the record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public createRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).createRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new record with the provided bins into the record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public createRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).createRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the specified record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public deleteRecordNamespaceKey(key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).deleteRecordNamespaceKey(key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the specified record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public deleteRecordNamespaceSetKey(key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).deleteRecordNamespaceSetKey(key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return the metadata and bins for a record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public getRecordNamespaceKey(key: string, namespace: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).getRecordNamespaceKey(key, namespace, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return the metadata and bins for a record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {Array<string>} [bins] Optionally specify a set of bins to return when fetching a record. If omitted, all bins will be returned.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public getRecordNamespaceSetKey(key: string, namespace: string, set: string, bins?: Array<string>, consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).getRecordNamespaceSetKey(key, namespace, set, bins, consistencyLevel, keytype, linearizeRead, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check if a record exists
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public recordExistsNamespaceKey(key: string, namespace: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any) {
        return KeyValueOperationsApiFp(this.configuration).recordExistsNamespaceKey(key, namespace, keytype, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check if a record exists
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public recordExistsNamespaceSetKey(key: string, namespace: string, set: string, keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', options?: any) {
        return KeyValueOperationsApiFp(this.configuration).recordExistsNamespaceSetKey(key, namespace, set, keytype, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace the bins of the specified record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public replaceRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).replaceRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace the bins of the specified record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public replaceRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).replaceRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Merge the provided bins into the record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public updateRecordNamespaceKey(bins: any, key: string, namespace: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).updateRecordNamespaceKey(bins, key, namespace, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Merge the provided bins into the record.
     * @param {any} bins Bins to be stored in the record. This is a mapping from a string bin name to a value. Value can be a String, integer, floating point number, list, map, bytearray, or GeoJSON value. Bytearrays and GeoJSON can only be sent using MessagePack example: {\&quot;bin1\&quot;:5, \&quot;bin2\&quot;:\&quot;hello\&quot;, \&quot;bin3\&quot;: [1,2,3], \&quot;bin4\&quot;: {\&quot;one\&quot;: 1}}
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyValueOperationsApi
     */
    public updateRecordNamespaceSetKey(bins: any, key: string, namespace: string, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return KeyValueOperationsApiFp(this.configuration).updateRecordNamespaceSetKey(bins, key, namespace, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

}

/**
 * OperateOperationsApi - fetch parameter creator
 * @export
 */
export const OperateOperationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceKey(key: string, namespace: string, operations: Array<Operation>, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling operateNamespaceKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling operateNamespaceKey.');
            }
            // verify required parameter 'operations' is not null or undefined
            if (operations === null || operations === undefined) {
                throw new RequiredError('operations','Required parameter operations was null or undefined when calling operateNamespaceKey.');
            }
            const localVarPath = `/v1/operate/{namespace}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Operation&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(operations || {}) : (operations || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceSetKey(key: string, namespace: string, operations: Array<Operation>, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling operateNamespaceSetKey.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling operateNamespaceSetKey.');
            }
            // verify required parameter 'operations' is not null or undefined
            if (operations === null || operations === undefined) {
                throw new RequiredError('operations','Required parameter operations was null or undefined when calling operateNamespaceSetKey.');
            }
            // verify required parameter 'set' is not null or undefined
            if (set === null || set === undefined) {
                throw new RequiredError('set','Required parameter set was null or undefined when calling operateNamespaceSetKey.');
            }
            const localVarPath = `/v1/operate/{namespace}/{set}/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"set"}}`, encodeURIComponent(String(set)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (commitLevel !== undefined) {
                localVarQueryParameter['commitLevel'] = commitLevel;
            }

            if (consistencyLevel !== undefined) {
                localVarQueryParameter['consistencyLevel'] = consistencyLevel;
            }

            if (durableDelete !== undefined) {
                localVarQueryParameter['durableDelete'] = durableDelete;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (generation !== undefined) {
                localVarQueryParameter['generation'] = generation;
            }

            if (generationPolicy !== undefined) {
                localVarQueryParameter['generationPolicy'] = generationPolicy;
            }

            if (keytype !== undefined) {
                localVarQueryParameter['keytype'] = keytype;
            }

            if (linearizeRead !== undefined) {
                localVarQueryParameter['linearizeRead'] = linearizeRead;
            }

            if (recordExistsAction !== undefined) {
                localVarQueryParameter['recordExistsAction'] = recordExistsAction;
            }

            if (replica !== undefined) {
                localVarQueryParameter['replica'] = replica;
            }

            if (sendKey !== undefined) {
                localVarQueryParameter['sendKey'] = sendKey;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Operation&gt;" as any !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(operations || {}) : (operations || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperateOperationsApi - functional programming interface
 * @export
 */
export const OperateOperationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceKey(key: string, namespace: string, operations: Array<Operation>, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
            const localVarFetchArgs = OperateOperationsApiFetchParamCreator(configuration).operateNamespaceKey(key, namespace, operations, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceSetKey(key: string, namespace: string, operations: Array<Operation>, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Record> {
            const localVarFetchArgs = OperateOperationsApiFetchParamCreator(configuration).operateNamespaceSetKey(key, namespace, operations, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OperateOperationsApi - factory interface
 * @export
 */
export const OperateOperationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceKey(key: string, namespace: string, operations: Array<Operation>, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return OperateOperationsApiFp(configuration).operateNamespaceKey(key, namespace, operations, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Perform multiple operations atomically on the specified record.
         * @param {string} key Userkey for the record.
         * @param {string} namespace Namespace for the record; equivalent to database name.
         * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
         * @param {string} set Set for the record; equivalent to database table.
         * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
         * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
         * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
         * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
         * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
         * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
         * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
         * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
         * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
         * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
         * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operateNamespaceSetKey(key: string, namespace: string, operations: Array<Operation>, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
            return OperateOperationsApiFp(configuration).operateNamespaceSetKey(key, namespace, operations, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(fetch, basePath);
        },
    };
};

/**
 * OperateOperationsApi - object-oriented interface
 * @export
 * @class OperateOperationsApi
 * @extends {BaseAPI}
 */
export class OperateOperationsApi extends BaseAPI {
    /**
     * 
     * @summary Perform multiple operations atomically on the specified record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperateOperationsApi
     */
    public operateNamespaceKey(key: string, namespace: string, operations: Array<Operation>, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return OperateOperationsApiFp(this.configuration).operateNamespaceKey(key, namespace, operations, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Perform multiple operations atomically on the specified record.
     * @param {string} key Userkey for the record.
     * @param {string} namespace Namespace for the record; equivalent to database name.
     * @param {Array<Operation>} operations An array of operation objects specifying the operations to perform on the record
     * @param {string} set Set for the record; equivalent to database table.
     * @param {'COMMIT_ALL' | 'COMMIT_MASTER'} [commitLevel] Desired consistency guarantee when committing a transaction on the server.
     * @param {'CONSISTENCY_ONE' | 'CONSISTENCY_ALL'} [consistencyLevel] How replicas should be consulted in a read operation to provide the desired consistency guarantee.
     * @param {boolean} [durableDelete] If the transaction results in a record deletion, leave a tombstone for the record.
     * @param {number} [expiration] Record expiration. Also known as ttl (time to live). Seconds record will live before being removed by the server.
     * @param {number} [generation] Expected generation. Generation is the number of times a record has been modified (including creation) on the server.
     * @param {'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT'} [generationPolicy] Qualify how to handle record writes based on record generation.
     * @param {'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST'} [keytype] The Type of the userKey.
     * @param {boolean} [linearizeRead] Force reads to be linearized for server namespaces that support strong consistency mode.
     * @param {'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY'} [recordExistsAction] How to handle the existence of the record. This is ignored for POST/PUT/UPDATE kvs methods.
     * @param {'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM'} [replica] Replica algorithm used to determine the target node for a single record command.
     * @param {boolean} [sendKey] Send user defined key in addition to hash digest on both reads and writes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperateOperationsApi
     */
    public operateNamespaceSetKey(key: string, namespace: string, operations: Array<Operation>, set: string, commitLevel?: 'COMMIT_ALL' | 'COMMIT_MASTER', consistencyLevel?: 'CONSISTENCY_ONE' | 'CONSISTENCY_ALL', durableDelete?: boolean, expiration?: number, generation?: number, generationPolicy?: 'NONE' | 'EXPECT_GEN_EQUAL' | 'EXPECT_GEN_GT', keytype?: 'STRING' | 'INTEGER' | 'BYTES' | 'DIGEST', linearizeRead?: boolean, recordExistsAction?: 'UPDATE' | 'UPDATE_ONLY' | 'REPLACE' | 'REPLACE_ONLY' | 'CREATE_ONLY', replica?: 'MASTER' | 'MASTER_PROLES' | 'SEQUENCE' | 'RANDOM', sendKey?: boolean, options?: any) {
        return OperateOperationsApiFp(this.configuration).operateNamespaceSetKey(key, namespace, operations, set, commitLevel, consistencyLevel, durableDelete, expiration, generation, generationPolicy, keytype, linearizeRead, recordExistsAction, replica, sendKey, options)(this.fetch, this.basePath);
    }

}

